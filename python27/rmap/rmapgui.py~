import kivy
kivy.require('1.8.0') # replace with your current kivy version !
from kivy.app import App
from kivy.uix.label import Label
from kivy.uix.button import Button
from kivy.uix.popup import Popup
from kivy.uix.tabbedpanel import TabbedPanel
from kivy.uix.textinput import TextInput
from kivy.uix.boxlayout import BoxLayout
#from kivy.uix.settings import Settings
from kivy.uix.image import Image
from kivy.properties import NumericProperty
from kivy.lang import Builder
from plyer import gps
from kivy.properties import StringProperty
from kivy.clock import Clock, mainthread
import re
import webbrowser
#from kivy.config import Config
import pickle
import random
import time
from datetime import datetime, timedelta
import rmapstation
import jsonrpc
from sensordriver import SensorDriver
from mapview import MapMarkerPopup
from mapview import MapView
from jnius import autoclass
from django.utils.translation import ugettext as _
from django.utils import translation
from kivy.lib import osc
from kivy.utils import platform
from kivy.uix.widget import Widget                                                              

platform = platform()

#if platform == 'android':
#    from android.runnable import run_on_ui_thread                                                   
#    WebView = autoclass('android.webkit.WebView')                                                   
#    WebViewClient = autoclass('android.webkit.WebViewClient')                                       
#    activity = autoclass('org.renpy.android.PythonActivity').mActivity                              
#
#
#    class Wv(Widget):
#        def __init__(self, **kwargs):
#            super(Wv, self).__init__(**kwargs)
#
#        def open(self,uri):
#            self.uri=uri
#            Clock.schedule_once(self.create_webview, 0)
#
#        @run_on_ui_thread
#        def create_webview(self, *args):
#            webview = WebView(activity)
#            webview.getSettings().setJavaScriptEnabled(True)
#            wvc = WebViewClient();
#            webview.setWebViewClient(wvc);
#            activity.setContentView(webview)
#            webview.loadUrl(self.uri)


#Config.adddefaultsection("rmap")
#Config.setdefault("rmap", "user", "rmap")

kv='''
#### _("string") here is not usefull because makemessages do catch it
####:import _ django.utils.translation.ugettext
#:import MapSource mapview.MapSource
#:import RiseInTransition kivy.uix.screenmanager.RiseInTransition
###:import camera plyer.camera

<Toolbar@BoxLayout>:
    size_hint_y: None
    height: '40dp'
    padding: '2dp'
    spacing: '2dp'

    canvas:
        Color:
            rgba: .2, .2, .2, .6
        Rectangle:
            pos: self.pos
            size: self.size


<mytextinput>:
    text: ''
    multiline: False
    on_text_validate: self.validatetext()


<MyMapMarker>:

ScreenManager:
    id: screenmanager
    transition: RiseInTransition()

    Screen:
        name: "Location"
        id: locationscreen

        MapView:
            #on_map_relocated: app.map_relocated(self.lat,self.lon)
            id: mapview
            lat: 45.
            lon: 11.
            zoom: 8
            #size_hint: .5, .5
            #pos_hint: {"x": .25, "y": .25}

            MirinoImage:
                id: mirino
                center: self.parent.center
                #center: mapview.get_window_xy_from(mapview.lat, mapview.lon, mapview.zoom)

            MyMapMarker:
                id: marker
                lat: app.lat
                lon: app.lon

                popup_size: dp(150), dp(100)

                Bubble:
                    BoxLayout:
                        orientation: "horizontal"
                        padding: "5dp"
                        Label:
                            id: markerlabel
                            text: app.str_lat_lon_height % (app.location,app.lat,app.lon,app.height)
                            markup: True
                            halign: "center"


        GridLayout:
            orientation: 'vertical'
            cols: 1
            row_force_default: True
            row_default_height: "40dp"

            Toolbar:

                Button:
                    text:  app.str_Settings

                    on_release:
                        app.open_settings() 

                Label:
                    text:   app.str_Select_Location
                    color:  1., .5, .5, 1.
                    bold: True

                Button:
                    text:   app.str_Next
                    on_release:
                        screenmanager.current = screenmanager.next()

            Toolbar:

                ToggleButton:
                    text: app.str_Start_GPS if self.state == 'normal' else app.str_Stop_GPS
                    on_state: app.startgps() if self.state == 'down' else app.stopgps()

                ToggleButton:
                    text: app.str_Start_Trip if self.state == 'normal' else app.str_Stop_Trip
                    on_state: app.starttrip() if self.state == 'down' else app.stoptrip()


                Button:
                    text: app.str_Save_Location
                    on_press: app.savelocation()



        StackLayout:
            orientation: "lr-bt"
            id: locationlayout

            Toolbar:
                height: '20dp'
                padding: '2dp'
                spacing: '2dp'
                Label:
                    id: lon
                    text: "Lon: {:4.5f}".format(mapview.lon)
                Label:
                    id: height
                    text: app.str_Height.format(app.height)
                Label:
                    id: lat
                    text: "Lat: {:4.5f}".format(mapview.lat)

            Toolbar:
                height: '20dp'
                padding: '2dp'
                spacing: '2dp'

                Label:
                    text: app.gps_location
            Toolbar:
                height: '20dp'
                padding: '2dp'
                spacing: '2dp'
                Label:
                    text: app.gps_status 

    Screen:
        name: "Data"
        id: datascreen

        canvas:
            Color:
                rgba: 50/255., 100/255., 50/255., 1
            Rectangle:
                pos: self.pos
                size: self.size


        GridLayout:
            orientation: 'vertical'
            cols: 1
            #row_force_default: True
            #row_default_height: '40dp'

            Toolbar:

                Button:
                    text: app.str_Previous
                    on_release:
                        screenmanager.current = screenmanager.previous()

                Label:
                    text: app.str_Insert_data
                    color:  1., .5, .5, 1.
                    bold: True

                Button:
                    text: app.str_Next
                    on_release:
                        screenmanager.current = screenmanager.next()

            TabbedPanel:
                do_default_tab: False

                TabbedPanelItem:
                    text: app.str_Meteo

                    GridLayout:
                        orientation: 'vertical'
                        cols: 1
                        row_force_default: True
                        row_default_height: '40dp'

                        canvas:
                            Color:
                                rgba: 50/255., 100/255., 50/255., 1
                            Rectangle:
                                pos: self.pos
                                size: self.size

                        BoxLayout:
                            canvas:
                                Color:
                                    rgba: 100/255., 100/255., 50/255., 1
                                Rectangle:
                                    pos: self.pos
                                    size: self.size
                            Label:
                                text: app.str_Snow_height
                            mytextinput:
                                id: snow
                        BoxLayout:
                            canvas:
                                Color:
                                    rgba: 50/255., 100/255., 100/255., 1
                                Rectangle:
                                    pos: self.pos
                                    size: self.size
                            Label:
                                text: app.str_Visibility
                            mytextinput:
                                id: fog

                TabbedPanelItem:
                    text: app.str_Air_Quality
                    GridLayout:
                        orientation: 'vertical'
                        cols: 1
                        row_force_default: True
                        row_default_height: '40dp'

                        Label:
                            text: app.str_Air_quality_tab_content_area

                TabbedPanelItem:
                    text: app.str_Special
                    GridLayout:
                        orientation: 'vertical'
                        cols: 1
                        row_force_default: True
                        row_default_height: '40dp'

                        Label:
                            text: app.str_Special_tab_content_area


        StackLayout:
            orientation: "lr-bt"
            id: bluelayout
            height: '40dp'
            padding: '2dp'
            spacing: '2dp'

            Toolbar:

                Button:
                    text: app.str_Queue_data_to_be_published
                    on_press: app.queuedata() 


    Screen:
        name: "Bluetooth"
        id: bluetooth


        GridLayout:
            orientation: 'vertical'
            cols: 1
            row_force_default: True
            row_default_height: '40dp'
            canvas:
                Color:
                    rgba: 50/255., 50/255., 100/255., 1
                Rectangle:
                    pos: self.pos
                    size: self.size

            Toolbar:

                Button:
                    text: app.str_Previous
                    on_release:
                        screenmanager.current = screenmanager.previous()

                Label:
                    text: app.str_Automatic_data
                    color:  1., .5, .5, 1.
                    bold: True

                Button:
                    text: app.str_Next
                    on_release:
                        screenmanager.current = screenmanager.next()


            Toolbar:

                Button:
                    id: configure
                    text: app.str_setup
                    #on_release: app.bluetoothconfigure() if app.bluetooth is not None else app.popup('Bluetooth disabled')
                    on_release: app.bluetoothconfigure()
                Button:
                    id: getdata
                    text: app.str_getdata
                    #on_release: app.bluetoothgetdata() if app.bluetooth is not None else app.popup('Bluetooth disabled')
                    on_release: app.bluetoothgetdata()

            Toolbar:

                ToggleButton:
                    text: app.str_Start_bluetooth if self.state == 'normal' else app.str_Stop_bluetooth
                    on_state: app.bluetoothconnect() if self.state == 'down' else app.bluetoothclose()

                ToggleButton:
                    text: app.str_Sample_ON if self.state == 'normal' else app.str_Sample_OFF
                    on_state: app.bluetoothsampleon() if self.state == 'down' else app.bluetoothsampleoff()
                    #on_release: app.bluetoothsampleon() if app.bluetooth is not None else app.popup(app.str_Bluetooth_disabled)

            Label:
                text: app.bluetooth_message 


        StackLayout:
            orientation: "lr-bt"
            id: bluelayout
            height: '40dp'
            padding: '2dp'
            spacing: '2dp'

            Toolbar:
                Label:
                    text: app.bluetooth_status 

    Screen:
        name: "Publish"
        id: publishscreen

        canvas:
            Color:
                rgba: 100/255., 50/255., 50/255., 1
            Rectangle:
                pos: self.pos
                size: self.size

        GridLayout:
            orientation: 'vertical'
            cols: 1
            row_force_default: True
            row_default_height: '40dp'

            Toolbar:

                Button:
                    text: app.str_Previous
                    on_release:
                        screenmanager.current = screenmanager.previous()

                Label:
                    text: app.str_Publish
                    color:  1., .5, .5, 1.
                    bold: True

                Button:
                    text: app.str_Settings
                    on_release:
                        app.open_settings() 

#                    text: app.str_Next
#                    on_release:
#                        screenmanager.current = screenmanager.next()

            Toolbar:

                Button:
                    text: app.str_Register
                    on_press: app.register() 

                Button:
                    text: app.str_View_graph
                    on_press: app.view() 

            Toolbar:

                ToggleButton:
                    text: app.str_Connect if self.state == 'normal' else app.str_Disconnect
                    on_state: app.startmqtt() if self.state == 'down' else app.stopmqtt()

                Button:
                    text: app.str_Clean_Queue
                    on_press: app.cleandata() 

#                Button:
#                    text: app.str_Publish
#                    on_press: app.publishmqtt() 


        StackLayout:
            orientation: "lr-bt"
            id: queuelayout
            height: '40dp'
            padding: '2dp'
            spacing: '2dp'

            Toolbar:
                Label:
                    text: app.mqtt_status 

            Toolbar:
                height: '350dp'
                ScrollView:
                    size_y: '350dp'
                    bar_width: 10
                    Label:

                        height: self.texture_size[1]
                        text_size: self.width, None

                        id: queue
                        text: app.str_Queue_status
                        markup: True
                        halign: "left"
                        size_hint_y: None

#    Screen:
#        name: "Camera"
#        id: camerascreen
#
#        BoxLayout:
#            orientation: 'vertical'
#            canvas:
#                Color:
#                    rgba: 50/255., 50/255., 100/255., 1
#                Rectangle:
#                    pos: self.pos
#                    size: self.size
#
#            camera:
#                id: mycamera
#                resolution: 399, 299
#
#            BoxLayout:
#                orientation: 'horizontal'
#                size_hint_y: None
#                height: '40dp'
#                Button:
#                    text: app.str_Start
#                    on_release: mycamera.play = True
#
#                Button:
#                    text: app.str_Stop
#                    on_release: mycamera.play = False

'''

def nint(x):
    """
    iround(number) -> integer
    Round a number to the nearest integer.
    """

    y = round(x) - .5
    return int(y) + (y > 0)

class MirinoImage(Image):

    def __init__(self, **kwargs):
        super(MirinoImage, self).__init__(**kwargs)
        self.source= 'mirino.png'
        #self.pos_hint= {'center_x': 0.5, 'center_y': 0.5}
        #self.center=(300.,300.)


class MyMapMarker(MapMarkerPopup):

    def location(self,lat,lon):

        #lat = NumericProperty(lat)
        #lon = NumericProperty(lon)
        self.lat = lat
        self.lon = lon


class mytextinput(TextInput):

    pat = re.compile('[^0-9]')

    def validatetext(self):
#        print 'Inserted:', self.text
        try:
            if float(self.text) > 999999. or float(self.text) < 0.:
                self.text=''
        except:
                self.text=''

    def insert_text(self, substring, from_undo=False):

#  disabled for now ... do not work on android!

#        pat = self.pat
#        if '.' in self.text:
#            s = re.sub(pat, '', substring)
#        else:
#            s = '.'.join([re.sub(pat, '', s) for s in substring.split('.', 1)])
#        return super(mytextinput, self).insert_text(s, from_undo=from_undo)

        return super(mytextinput, self).insert_text(substring, from_undo=from_undo)


#class MyTab(TabbedPanel):
#    pass


class Rmap(App):

    title = 'RMAP'
    
    gps_status = StringProperty(_('Start GPS to get location updates'))
    gps_location = StringProperty(_('wait for location'))
    mqtt_status = StringProperty(_('Connect Status:'))
    bluetooth_message=StringProperty("")
    bluetooth_status = StringProperty(_('BlueTooth Status: DISCONNECTED'))

    gpsfix=False
    mqtt_connected = False
    gps_conn = False
    reconnectonresume=False
    datavarlist=[]

    #disable the section kivy in config panel
    use_kivy_settings = False
    trip=False


    def translate(self):

        translation.activate(self.config.get('general','language'))

        self.str_Settings=_("Settings")
        self.str_Select_Location=_("Select Location")
        self.str_Next=_("Next")
        self.str_Start_GPS=_("Start GPS") 
        self.str_Stop_GPS=_("Stop GPS")
        self.str_Start_Trip=_("Start Trip")
        self.str_Stop_Trip=_("Stop Trip")
        self.str_Save_Location=_("Save Location")
        self.str_Height=_("Height: {:4.0f}")
        self.str_Previous=_("Previous")
        self.str_Insert_data=_("Insert data")
        self.str_Queue_data_to_be_published=_("Queue data to be published")
        self.str_Meteo=_("Meteo")
        self.str_Snow_height=_("Snow height(cm.)")
        self.str_Visibility=_("Visibility(m.)")
        self.str_Air_Quality=_("Air Quality")
        self.str_Special_tab_content_area=_("Special tab content area\n to be done")
        self.str_Air_quality_tab_content_area=_("Air Quality tab content area\n to be done")
        self.str_Automatic_data=_("Automatic data")
        self.str_Next=_("Next")
        self.str_setup=_("Setup")
        self.str_configure_board=_("Configure")
        self.str_getdata=_("Getdata")
        self.str_Start_bluetooth=_("Start bluetooth")
        self.str_Stop_bluetooth=_("Stop bluetooth")
        self.str_Sample_ON=_("Sample ON")
        self.str_Sample_OFF=_("Sample OFF")
        self.str_Publish=_("Publish")
        self.str_Register=_("Register")
        self.str_View_graph=_("View graph")
        self.str_Connect=_("Connect") 
        self.str_Disconnect=_("Disconnect")
        self.str_Clean_Queue=_("Clean Queue")
        self.str_Queue_status=_("Queue status")
        self.str_Special=_("Special")
        self.str_lat_lon_height=_("[b]%s\nLat: %4.5f\nLon: %4.5f\nHeight: %d[/b]")

    def on_stop(self):
        '''
        called on appication stop
        Here you can save data if needed
        '''
        print ">>>>>>>>> called on appication stop"

        self.stop_service()

        if self.mqtt_connected:
            print "stop mqtt"
            self.stopmqtt()

        if self.gps_conn :
            print "stop gps"
            self.stopgps()

        pickle.dump( self.datavarlist, open( "saveddata.pickle", "wb" ) )

    def on_pause(self):
        '''
        called on application pause
        Here you can save data if needed
        '''
        print ">>>>>>>>> called on application pause"

        if self.gps_conn:
            print "stop gps"
            self.gps.stop()

        if self.mqtt_connected:
            print "stop mqtt"
            self.stopmqtt()
            self.reconnectonresume=True

        pickle.dump( self.datavarlist, open( "saveddata.pickle", "wb" ) )

        return True

    def on_resume(self):
        '''
        called on appication resume
        Here you can check if any data needs replacing (usually nothing)
        '''
        print ">>>>>>>>> called on appication resume"

        try:
            print "load saved data"
            self.datavarlist= pickle.load( open( "saveddata.pickle", "rb" ) )
        except:
            print "ERROR loading saved data"
            self.datavarlist=[]

        self.root.ids["queue"].text=self.queue2str()

        if self.reconnectonresume == True :
            print "start mqtt"
            self.startmqtt()

        if self.gps_conn :
            print "start gps"
            self.gps.start()


    def on_config_change(self, config, section, key, value):
        ''' called when config is changed '''

        mqttchanged = False
        locationchanged = False
        languagechanged = False

        if config is self.config:
            token = (section, key)

            if token == ('general', 'language'):
                print('language have been changed to', value)
                languagechanged = True

            elif token == ('mqtt', 'mqttserver'):
                print('mqttserver have been changed to', value)
                mqttchanged = True
            elif token == ('mqtt', 'user'):
                print('user have been changed to', value)
                mqttchanged = True
            elif token == ('mqtt', 'password'):
                print('password have been changed to', value)
                mqttchanged = True
            elif token == ('mqtt', 'ident'):
                print('ident have been changed to', value)
                mqttchanged = True


            elif token == ('location', 'name'):
                print('location name have been changed to', value)
                locationchanged = True
            elif token == ('location', 'lat'):
                print('lat have been changed to', value)
                locationchanged = True
            elif token == ('location', 'lon'):
                print('lon have been changed to', value)
                locationchanged = True
            elif token == ('location', 'height'):
                print('height have been changed to', value)
                locationchanged = True

            if mqttchanged and self.mqtt_connected:
                print "reconnect MQTT with new parameter"
                self.stopmqtt()
                self.startmqtt()

            if locationchanged:
                print "save location with new parameter"

                self.location=self.config.get('location','name')
                self.lon=float(self.config.get('location','lon'))
                self.lat=float(self.config.get('location','lat'))
                self.height=float(self.config.get('location','height'))

                self.updatelocation()

            if languagechanged:
                self.popup("Restart APP")


    def start_service(self):
        if platform == 'android':
            from android import AndroidService
            service = AndroidService('rmap background', 'running')
            service.start('service started') # Argument to pass to a service, through the environment variable PYTHON_SERVICE_ARGUMENT.
            self.service = service

    def stop_service(self):
        if self.service:
            self.service.stop()
            self.service = None


    def build_config(self, config):

        config.setdefaults('general', {
            'language': 'it',
        })

        config.setdefaults('mqtt', {
            'user': 'your user',
            'password': 'your password',
            'mqttserver': 'rmap.cc',
            'ident': 'mobile'
        })

        config.setdefaults('location', {
            'name': 'home',
            'lat': 0.,
            'lon': 0.,
            'height': 0.
        })

        config.setdefaults('bluetooth', {
            'name': 'stima',
            'samplerate': 5.,
        })

    def build_settings(self, settings):
        '''
        define the setting panel
        '''

        jsongeneral = """
[
    { "type": "title",
      "title": "General configuration" },

    { "type": "options",
      "title": "Language",
      "desc": "Language to use in application",
      "section": "general",
      "key": "language",
      "options": ["it","en"]}
]
        """

        jsonrmap = """
[
    { "type": "title",
      "title": "Rmap configuration" },

    { "type": "string",
      "title": "MQTT user",
      "desc": "MQTT user to connet to rmap server",
      "section": "mqtt",
      "key": "user"},

    { "type": "string",
      "title": "MQTT password",
      "desc": "MQTT password to connet to rmap server",
      "section": "mqtt",
      "key": "password"},

    { "type": "string",
      "title": "MQTT server",
      "desc": "MQTT server",
      "section": "mqtt",
      "key": "mqttserver"},

    { "type": "string",
      "title": "station identifier",
      "desc": "station ident",
      "section": "mqtt",
      "key": "ident"}

]
        """

        jsonlocation = """
[
    { "type": "title",
      "title": "Location" },

    { "type": "string",
      "title": "Name",
      "desc": "Location name",
      "section": "location",
      "key": "name"},
    { "type": "numeric",
      "title": "Latitude",
      "desc": "Latitude (decimal)",
      "section": "location",
      "key": "lat"},
    { "type": "numeric",
      "title": "Longitude",
      "desc": "Longitude (decimal)",
      "section": "location",
      "key": "lon"},
    { "type": "numeric",
      "title": "Height",
      "desc": "Ground Height  (m.)",
      "section": "location",
      "key": "height"}
]
        """


        jsonbluetooth = """
[
    { "type": "title",
      "title": "Bluetooth" },

    { "type": "string",
      "title": "Name",
      "desc": "bluetooth name",
      "section": "bluetooth",
      "key": "name"},
    { "type": "numeric",
      "title": "Sample Time",
      "desc": "Sample Time Frequecy (s.)",
      "section": "bluetooth",
      "key": "samplerate"}

]
        """

        settings.add_json_panel('General',
                                self.config, data=jsongeneral)

        settings.add_json_panel('Rmap',
                                self.config, data=jsonrmap)

        settings.add_json_panel('Location',
                                self.config, data=jsonlocation)

        settings.add_json_panel('Bluetooth',
                                self.config, data=jsonbluetooth)

    def bluetoothconnect(self):
        try:
            self.bluetooth=jsonrpc.TransportBLUETOOTH(name=self.config.get('bluetooth','name'),timeout=3, logfunc=jsonrpc.log_stdout)
            self.bluetooth_status='BlueTooth Status: CONNECTED'

            if self.bluetooth.recv_stream is None or self.bluetooth.send_stream is None:
                self.bluetooth=None
                self.bluetooth_status='BlueTooth Status: DISABLED'
                self.popup("cannot activate\nbluetooth")
                return

            self.drivers=[]
            self.drivers.append(SensorDriver.factory("JRPC",transport=self.bluetooth))
            for driver in self.drivers:
              try:
                driver.setup(driver="I2C",node=0,type="TMP",address=72)
              except:
                print "ERROR executing setup rpc"
            for driver in self.drivers:
                driver.setup()

        except:
            self.popup("cannot activate\nbluetooth")
            self.bluetooth=None
            self.bluetooth_status='BlueTooth Status: ERROR'
            raise

    def bluetoothclose(self):

        if self.bluetooth is None:
            self.popup("bluetooth disabled")
            return

        try:
            self.bluetooth.close()
            self.bluetooth_status='BlueTooth Status: DISCONNECTED'
        except:
            self.bluetooth_status='BlueTooth Status: ERROR'

        self.bluetooth=None

    def bluetoothconfigure(self):

        if self.bluetooth is None:
            self.popup("bluetooth disabled")
            return

        if self.bluetooth.send_stream is None or self.bluetooth.recv_stream is None:
            self.bluetooth_status="BlueTooth Status: ERROR"

        #using transport
        #cmd='{"jsonrpc": "2.0", "method": "configure", "params": {"reset": true}, "id": 0}'
        #self.bluetooth.send(cmd)
        #self.bluetooth_message=self.bluetooth.recv()

        #cmd='{"jsonrpc": "2.0", "method": "configure", "params": {"node": 1, "type": "TMP", "mqttpath": "254,0,0/105,2,-,-/", "driver": "TMP", "address": 72}, "id": 0}'
        #self.bluetooth.send(cmd)
        #self.bluetooth_message+=self.bluetooth.recv()

        #using proxy
        jsonrpcproxy=jsonrpc.ServerProxy( jsonrpc.JsonRpc20(),self.bluetooth)
        try:
            jsonrpcproxy.configure(reset=True)
            jsonrpcproxy.configure(node=0, type="TMP", mqttpath="254,0,0/105,2,-,-/", driver="I2C", address= 72)
            jsonrpcproxy.configure(save=True)
            self.bluetooth_status="BlueTooth Status: OK"
        except:
            self.bluetooth_status="BlueTooth Status: ERROR"

    def bluetoothgetdata(self):

        if self.bluetooth is None:
            self.popup("bluetooth disabled")
            return False

        dt=0
        for driver in self.drivers:
            print "prepare: ",driver
            try:
                dt=max(driver.prepare(),dt)
            except:
                print "ERROR executing prepare rpc"
                self.popup("ERROR getting\ndata from\nbluetooth")

        print "sleep:",dt
        time.sleep(dt/1000.)

        self.bluetooth_message=""
        for driver in self.drivers:
            try:
              for btable,value in driver.get().iteritems():
                datavar={btable:{"t": datetime.utcnow(),"v": str(value)}}
                self.datavarlist.append({"coord":{"lat":self.lat,"lon":self.lon},"datavar":datavar})
                stringa =""
                for btable,data in datavar.iteritems():
                    stringa += btable+": "+ data["t"].strftime("%d/%m/%y %H:%M:%S")+" -> "+str(data["v"])+"\n"
                self.bluetooth_message=stringa

            except:
                print "ERROR executing getJson rpc"
                self.popup("ERROR getting\ndata from\nbluetooth")

        self.root.ids["queue"].text=self.queue2str()
        return True

    def bluetoothsampleon(self):

        self.mybluetoothloop=self.bluetooth_loop
        Clock.schedule_interval(self.mybluetoothloop, float(self.config.get('bluetooth','samplerate')))

    def bluetoothsampleoff(self):
        Clock.unschedule(self.mybluetoothloop)

    def rpcin(self, message, *args):
        print "RPC: ",message[2]

    def rpcout(self, *args):
        osc.sendMsg('/rpc', ["testinout",], port=3000)

    def build(self):
        '''
        build application
        '''

        self.translate()

        self.gps = gps
        try:
            self.gps.configure(on_location=self.on_location,
                    on_status=self.on_status)
        except NotImplementedError:
            self.gps_status="GPS not implemented in this platform"
            self.gps_location=""

        self.location=self.config.get('location','name')
        self.lon=float(self.config.get('location','lon'))
        self.lat=float(self.config.get('location','lat'))
        self.height=float(self.config.get('location','height'))

        self.bluetooth=None
        self.bluetooth_status='BlueTooth Status: DISCONNECTED'

        try:
            self.datavarlist= pickle.load( open( "saveddata.pickle", "rb" ) )
        except:
            print "ERROR loading saved data"
            self.datavarlist=[]

        self.service = None
        #self.start_service()
        osc.init()
        oscid = osc.listen(port=3001)
        osc.bind(oscid, self.rpcin, '/rpc')
        Clock.schedule_interval(lambda *x: osc.readQueue(oscid), 0)
        Clock.schedule_interval(self.rpcout, 5)

        Clock.schedule_interval(self.mqtt_loop, 5)

        root= Builder.load_string(kv)

        print self.datavarlist
        root.ids["queue"].text=self.queue2str()

        #root = ScreenManager()
        #root.add_widget(LocationScreen())
        #root.add_widget(DataScreen())
        #root.add_widget(PublishScreen())

        return root

    def popup(self,message):

        box = BoxLayout(orientation='vertical')
        label = Label(text=message)
        bottone = Button(text='Close!')

        box.add_widget(label)
        box.add_widget(bottone)

        popup = Popup(title='warning', content=box,size_hint=(.5, .5))
        bottone.bind(on_press=popup.dismiss)
        popup.open()

    def register(self):

#        if platform == 'android':
#            browser=Wv()
#            browser.open("http://rmap.cc/registrazione/register/")
#        else:
            webbrowser.open("http://rmap.cc/registrazione/register/")


    def view(self):

#        if platform == 'android':
#            browser=Wv()
#            browser.open("http://graphite.rmapv.rmap.cc/render?width=800&height=600&from=-1hours&until=now&target=rmap.*.*.*.*.105_2_-_-.*.v")
#        else:
            webbrowser.open("http://graphite.rmapv.rmap.cc/render?width=800&height=600&from=-1hours&until=now&target=rmap.*.*.*.*.105_2_-_-.*.v")

    def starttrip(self):
        self.trip=True

    def stoptrip(self):
        self.trip=False

    def startgps(self):
        ''' start use GPS'''

        try:
            self.gps.start()
            self.gps_status="Starting GPS: wait ..."
            self.gps_location=""
            self.gps_conn = True

        except NotImplementedError:
            self.popup('GPS not\nimplemented on\nthis platform')

            self.gps_status="GPS not implemented in this platform"
            self.gps_location=""

#        self.root.ids["locationlayout"].add_widget(Label(text=self.gps_status))


    def stopgps(self):
        ''' stop use of GPS'''
        if self.gps_conn:
            self.gps.stop()
        self.gps_status = 'GPS OFF'
        self.gps_location=""
        self.gps_conn = False



    def startmqtt(self):
        '''
        begin mqtt connection
        and publish constat station data
        '''
        config = self.config

        if self.lat is None or self.lon is None:
            print "you have to set LAT and LON"
            self.mqtt_status = _('Connect Status: ERROR, you have to define a location !')
            return

        try:
            self.rmap=rmapstation.rmapmqtt(ident=config.get('mqtt','ident'),lon=self.lon,lat=self.lat,host=config.get('mqtt','mqttserver'),username=config.get('mqtt','user'),password=config.get('mqtt','password'),prefix="rmap",maintprefix="rmap")

            anavar={
                "B07030":{"v": self.height}
            }

            self.rmap.ana(anavar)
            self.mqtt_connected = True
            self.mqtt_status = _('Connect Status: OK connected')
        except:
            self.mqtt_connected = False
            self.mqtt_status = ('Connect Status: ERROR connecting')

    def updatelocation(self):
        '''
        update a new location
        '''

        self.root.ids["marker"].location(self.lat,self.lon)
        self.root.ids["markerlabel"].text= self.str_lat_lon_height % (self.location,self.lat,self.lon,self.height)

        self.root.ids["mapview"].do_update(10)
        self.root.ids["height"].text= self.str_Height.format(self.height)


    def savelocation(self,lat=None,lon=None,height=None,location=None):
        '''
        set a new location
        '''

        self.root.ids["mapview"].do_update(10)

        if location is None:
            self.location=""
        else:
            self.location=location

        if lat is None:
            self.lat=nint(self.root.ids["mapview"].lat*100000)/100000.
        else:
            self.lat=lat

        if lon is None:
            self.lon=nint(self.root.ids["mapview"].lon*100000)/100000.
        else:
            self.lon=lon

        if height is not None:
            self.height=height
        else:
            if not self.gpsfix or not self.gps_conn:
                self.height=0

        self.updatelocation()

        if not self.trip:
            print "save new location in config"
            self.config.set('location', 'name',self.location)
            self.config.set('location', 'lat',self.lat)
            self.config.set('location', 'lon',self.lon)
            self.config.set('location', 'height',self.height)
            self.config.write()

        #    def map_relocated(self,lat,lon):
        #       pass


    def queue2str(self):
        stringa=""
        for item in self.datavarlist:
            for btable,data in item["datavar"].iteritems():
                stringa += btable+" {:4.5f}".format(item["coord"]["lat"])+",{:4.5f} ".format(item["coord"]["lon"])+data["t"].strftime("%d/%m/%y %H:%M:%S")+" -> "+str(data["v"])+"\n"
        return stringa

    def queuedata(self):
         print self.root.ids
         try:
            value=float(self.root.ids["fog"].text)/10
            datavar={"B20001":{"t": datetime.utcnow(),"v": str(value)}}
            self.root.ids["fog"].text=""
            self.datavarlist.append({"coord":{"lat":self.lat,"lon":self.lon},"datavar":datavar})
         except:
            pass
            
         try:
            value=float(self.root.ids["snow"].text)*10
            datavar={"B13013":{"t": datetime.utcnow(),"v": str(value)}}
            self.root.ids["snow"].text=""
            self.datavarlist.append({"coord":{"lat":self.lat,"lon":self.lon},"datavar":datavar})
         except:
            pass
            
         print self.datavarlist
         self.root.ids["queue"].text=self.queue2str()


    def cleandata(self):
         self.datavarlist=[]
         self.root.ids["queue"].text=""

    
    def publishmqtt(self):
        '''
        publish data on mqtt server
        '''

        # here we generate randon data to test only 
        #-----------------------------------------------------------
        timerange="254,0,0"               # dati istantanei
        level="105,2,-,-"                 # livello fittizio 2

#        value=random.randint(25315,30000) # tempertaure in cent K
#        datavar={"B12101":
#                 {
#                     "t": datetime.utcnow(),
#                     "v": str(value),
#                     "a": {
#                         "B33194": "90",           # attributi di qualita' del dato
#                         "B33195": "85"
#                     }   
#                 }}

        #-----------------------------------------------------------

        print "queue",self.datavarlist
        if self.mqtt_connected:
            newdatavarlist=[]
            for item in self.datavarlist:
                print "try to publish",item
                try:
                    self.rmap.data(timerange,level,item["datavar"],lon=item["coord"]["lon"],lat=item["coord"]["lat"])
                    self.mqtt_status = _('Connect Status: Published')
                    print "pubblicato", item["datavar"]
                except:
                    newdatavarlist.append(item)
                    self.mqtt_status = _('Connect Status: ERROR on Publish')

            self.datavarlist=newdatavarlist
            self.root.ids["queue"].text=self.queue2str()
        else:
            self.mqtt_status = _('Connect Status: ERROR on Publish, not connected')

    def stopmqtt(self):
        '''
        disconnect from mqtt server
        '''

        if self.mqtt_connected:
           try:
              self.rmap.disconnect()
           except:
              pass

        self.mqtt_status = _('Connect Status: disconnected')

        self.mqtt_connected = False
        #Config.write()


    @mainthread
    def mqtt_loop(self, *args):
        '''
        This function is the driving force behind the mqtt client. If they
        are not called, incoming network data will not be processed
        and outgoing network data may not be sent in a timely fashion.
        '''

        print "call in loop"
        if self.mqtt_connected:        
            print "call rmap sleep"
            self.rmap.sleep()
            self.publishmqtt()
        return True

    @mainthread
    def bluetooth_loop(self, *args):
        '''
        This function manage jsonrpc bluetooth serial messages.
        '''

        print "call in bluetooth loop"

        if self.bluetooth is not None:
            if self.trip:
                if self.gpsfix:
                    return self.bluetoothgetdata()
            else:
                    return self.bluetoothgetdata()

        return True


    @mainthread
    def on_location(self, **kwargs):
        '''
        callback for new GPS location
        '''

#        self.gps_location = '\n'.join([
#            '{}={}'.format(k, v) for k, v in kwargs.items()])
        lat=nint(kwargs["lat"]*100000)/100000.
        lon=nint(kwargs["lon"]*100000)/100000.
        height=int(kwargs["altitude"])
        self.gps_location = 'GPS: new coordinate acquired'
        self.root.ids["mapview"].center_on(lat,lon)
        self.root.ids["height"].text= self.str_Height.format(height)

        self.gpsfix=True
        if self.trip and self.gpsfix:
            self.savelocation(lat=lat,lon=lon,height=height)


    @mainthread
    def on_status(self, stype, status):
        '''
        callback for new GPS status
        '''

        self.gps_status = 'type={}; {}'.format(stype, status)

        #mmm take alook at http://stackoverflow.com/questions/2021176/how-can-i-check-the-current-status-of-the-gps-receiver
        if status == "gps: available":
            self.gpsfix=True
        else:
            self.gpsfix=False

